
/* Resolva o problema utilizando os conceitos trabalhados em aulas, aplicados na linguagem C.
 1. Considerando o programa exemplo desenvolvido em aula, adapte o código para incluir as seguintes
operações para manipulação da lista:

    a. Inserir no final da lista
    b. Buscar por valor
    c. Buscar por posição
    d. Remover do final
    e. Remover por posição
    f. Remover por valor
    g. Imprimir apenas elementos pares (ou ímpares)
    h. Finalizar programa
    
Importante: para cada opção selecionada, verifique a possibilidade de sua execução, informando caso
alguma solicitação não possa ser atendida (ex: tentar excluir um elemento de uma lista vazia).
Desafio: implemente uma função recursiva e uma função não recursiva para contar a quantidade de
elementos na lista. */
#include <stdio.h>
#include <stdlib.h>

typedef struct Node{
    int valor;
    struct Node *pPonteiro;
} node;


node* insereFinal(node *cabeca,int num);
void buscarValor(node *cabeca,int num);
void buscaPosicao(node *cabeca, int num);
node* removeFinal(node *cabeca);
void imprimir(node *cabeca);

int main () {
    node *cabeca = NULL;
    char opcao = 'z';
    int num;
    while (opcao != 'i'){
        printf ("\tMENU\n");
        printf ("a. Inserir no final da lista\n");
        printf ("b. Buscar por valor\n");
        printf ("c. Buscar por posição\n");
        printf ("d. Remover do final\n");
        printf ("e. Remover por posição\n");
        printf ("f. Remover por valor\n");
        printf ("g. Imprimir apenas elementos pares (ou ímpares)\n");
        printf ("h. Imprimir elementos\n");
        printf ("i. Finalizar programa\n");
        
        scanf (" %c", &opcao);
        getchar();

        switch (opcao){
            case 'a':
                printf ("Informe o valor : ");
                scanf ("%i", &num);
                cabeca = insereFinal(cabeca, num);  //pronto 
                break;
            case 'b':
                printf ("Informe o valor : ");
                scanf ("%d", &num);
                buscarValor(cabeca, num); //pronto
                break;
            case 'c':
                printf ("Informe a posição : ");
                scanf ("%d", &num);
                buscaPosicao(cabeca, num); //pronto
                break;
            case 'd':
                cabeca = removeFinal(cabeca); //n sei pq tem erro
                break;
            case 'e':
                break;
            case 'f':
                break;
            case 'g':
                break;
            case 'h':
                imprimir(cabeca); //pronto
                break;    
            case 'i':
                printf ("Programa Finalizado !\n"); //pronto
                return 0;
            default :
                printf ("Caractere inválido !"); //pronto
                break;
        }
        getchar();
    }
}    
node* insereFinal(node *cabeca,int num){
    node *novo =(node*) malloc(sizeof(node));
    novo->valor = num;
    novo->pPonteiro = NULL;
    
    if (cabeca == NULL){
        return novo;
    }

    node *aux = cabeca;
    while (aux->pPonteiro != NULL) {
        aux = aux->pPonteiro;
    }

    aux->pPonteiro = novo;
    return cabeca;

}

void buscarValor(node *cabeca,int num){
    node *aux = cabeca;
    int i=0;

    while (aux->pPonteiro != NULL){
        i++;
        if (aux->valor == num){
            printf ("\nVocê encontrou o valor %i na posição %i\n\n", num, i);
        }
        aux = aux->pPonteiro;
    }
    printf ("\nNão existe esse valor na lista\n\n");
}

void buscaPosicao(node *cabeca, int num){
    node *aux = cabeca;
    for (int i=0; i<num-1; i++){
        aux = aux->pPonteiro;
    }
    if (aux != NULL){
        printf ("\no valor na posicao %i é %i\n\n", num, aux->valor);
    }else{
        printf ("Não existe valor na posição %i\n", num);
    }
}

node* removeFinal(node *cabeca) {
    if (cabeca == NULL) {
        printf("Lista vazia.\n");
        return cabeca;  // Lista vazia, não há o que remover
    }

    // Caso a lista tenha apenas um nó
    if (cabeca->pPonteiro == NULL) {
        free(cabeca); // Remove o único nó
        printf("Elemento removido.\n");
        return NULL;  // Lista agora está vazia
    }

    node *aux = cabeca;
    node *penultimo = NULL;

    // Percorre até o penúltimo nó
    while (aux->pPonteiro != NULL) {
        penultimo = aux;
        aux = aux->pPonteiro;
    }

    // Agora `aux` é o último nó e `penultimo` é o penúltimo nó
    penultimo->pPonteiro = NULL;  // Remove a referência para o último nó
    free(aux);  // Libera a memória do último nó
    printf("Elemento removido.\n");

    return cabeca;  // Retorna a nova cabeça (caso a lista tenha mudado)
}



void imprimir(node *cabeca){
    if (cabeca == NULL) {
        printf("Lista vazia.\n");
        return;
    }

    node *temp = cabeca;
    while (temp != NULL) {
        printf("%d ", temp->valor);
        temp = temp->pPonteiro;
    }
    printf("\n");
}
